<!-- Generated by `build-agents-md.sh` from profile-based parts in `agents-rules/`. -->
# Project Guide (Codex Context)

## File Size & Modularity

- Do not allow large files. Large files are hard to read, hard to maintain, and lead to poor structure.
- Always extract related logic into small semantic modules and compose them through clear entry points.
- Keep project structure explicit and meaningful by feature/domain.
- Target file size: up to `150-200` lines for regular source files.
- If a file grows beyond `200` lines, split it by responsibility before continuing feature work.
- Code line length in files must strictly not exceed `120` characters.

## Code Clarity & Patterns

- Do not allow overengineering or accumulation of unrelated code in a single implementation.
- Keep code cohesive: one module/function should focus on one clear responsibility.
- Use appropriate design patterns (for example `Observer`, `Decorator`, `Strategy`) when they improve
  readability, predictability, and maintainability.
- Prefer solutions that are maximally clear for humans reading and maintaining the code.

## Frontend stack

- Next.js (App Router)
- TypeScript
- Supabase (Data + Auth) if needed
- Biome.js ONLY (no ESLint, Prettier, Stylelint)
- Git repo with .gitignore

## Frontend scripts

- `npm run dev`
- `npm run build`
- `npm run start`
- `npm run lint` (Biome)
- `npm run format` (Biome)
- `npm run typecheck`

## Architecture rules

- UI components must be dumb: only render UI and local UI state without business logic.
- No direct DB or API calls inside UI components.
- Components call custom hooks for data operations, business logic etc.
- Custom hooks use services like httpClient, localStorageService etc. - DI boundary.
- Custom hooks also encapsulate Supabase/API logic.
- Reusable logic + visuals belong in `src/features`.

## Suggested folders

- `src/app`: only holds route pages/layouts (and optional logo assets), not feature implementations.
- `src/features`: Finished features with UI and logic in hooks, collected in a single folder and used as a component in `src/app` pages.
- `src/shared`: shared types/utils

## Example flow

- Component -> `useReport()` hook -> Supabase.

## Non-goals

- No raw review text exposure.
- No direct DB calls in UI.

## Styling rules

- Use SCSS + CSS Modules for component styles (`*.module.css`). Do not create plain `.css` style files.
- Keep component styles next to the component in its folder.
- Global styles only for resets, theme tokens, and layout scaffolding.
- SVG icons are React components via SVGR. Store them in `src/icons` and import them in components (no inline SVG, no `<img>`).
- In all `*.scss` files, prefer SCSS nesting as much as practical to improve readability and maintainability.
- Keep theme styles split by component in separate files under `src/styles/theme/` (one component = one file).
- Import all component theme files via `src/styles/theme.scss` only.

## Ð¡SS Classnames

- Always use `clsx` from `@atlanticrev/atl-ui` if presented for combining/conditional CSS class names.
- If not presented, `src/lib/clsx.ts` implementation - `type ClassValue = string | number | false | null | undefined | ClassValue[] | Record<string, boolean>;

function toClassName(value: ClassValue, classes: string[]) {
	if (!value) {
		return;
	}

	if (typeof value === 'string' || typeof value === 'number') {
		classes.push(String(value));
		return;
	}

	if (Array.isArray(value)) {
		for (const item of value) {
			toClassName(item, classes);
		}
		return;
	}

	for (const [key, isActive] of Object.entries(value)) {
		if (isActive) {
			classes.push(key);
		}
	}
}

export function clsx(...values: ClassValue[]) {
	const classes: string[] = [];

	for (const value of values) {
		toClassName(value, classes);
	}

	return classes.join(' ');
}
`

## Markup formatting

- Add blank lines between meaningful JSX/HTML blocks to keep structure readable.

## Typing conventions

- Prefer explicit TypeScript types over `as const` for data dictionaries.
- Prefer TypeScript types over interfaces.

## Constants

- Avoid magic numbers/strings in code; extract them into named constants.

## JavaScript formatting

- In JS/TS object literals with more than one property, write each property on a new line.
- In JS/TS array literals with more than one element, write each element on a new line.

## Naming conventions

- Folder names are always kebab-case.
- Component names are PascalCase with no consecutive uppercase letters.

## Callbacks

- Avoid inline callbacks in props and object literals.
- Declare callbacks as named arrow functions and pass by reference.

## Functions

- Prefer arrow functions over `function` declarations when possible and convenient.
- Exceptions: generator functions and Next.js Page components can use `function`.

## State management

- If state logically groups multiple related properties, replace multiple `useState` calls with a single state object.

## Reuse & DRY

- Avoid duplication where practical; extract shared logic into helpers.
- Prefer placing reusable utilities (including generics) in `src/shared`.
- In a component file, allow only one TSX component declaration/export.
- If functions in the same component file are related to that component but declared outside the component body, move them to a nearby `utils` file.

## Hooks Organization

- Group related hooks together (e.g., `useId`, `useRef`, `useState`) and separate each group with a blank line.
- Keep `useState` declarations at the start of the component.
- Values derived for rendering should be declared close to the JSX return.

## Content dictionary

- Store UI texts in `src/shared/texts.ts`.

## Defaults

- Keep TS strict.
- Keep components presentational.
- Keep hooks types small and explicit.
- Prefer typed DTOs in `src/shared/types`.

## Buttons

- Do not use native HTML `<button>` directly; use the `Button` component from `@atlanticrev/atl-ui` (or a component library button) instead. If there are no UI Library with Button in this project then ok, use <button>.

## UI Components First

- When implementing a feature that uses UI elements, first check for suitable components in `@atlanticrev/atl-ui` if presented.
